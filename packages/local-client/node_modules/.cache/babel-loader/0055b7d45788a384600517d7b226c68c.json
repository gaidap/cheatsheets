{"ast":null,"code":"import produce from 'immer';\nimport { ActionType } from '../action-types';\nimport { Direction } from '../actions';\nconst initialState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {}\n};\nconst reducer = produce((state = initialState, action) => {\n  switch (action.type) {\n    case ActionType.MOVE_CELL:\n      moveCell(state, action);\n      return state;\n\n    case ActionType.UPDATE_CELL:\n      updateCell(state, action);\n      return state;\n\n    case ActionType.DELETE_CELL:\n      deleteCell(state, action);\n      return state;\n\n    case ActionType.INSERT_CELL_AFTER:\n      insertCellAfter(state, action);\n      return state;\n\n    default:\n      return state;\n  }\n});\n\nconst moveCell = (state, action) => {\n  const {\n    direction\n  } = action.payload;\n  const currentIndex = findIndexByPayloadId(state, action);\n  const newIndex = direction === Direction.UP ? currentIndex - 1 : currentIndex + 1;\n  const indexOutOfBounds = newIndex < 0 || newIndex >= state.order.length;\n\n  if (indexOutOfBounds) {\n    return;\n  }\n\n  state.order[currentIndex] = state.order[newIndex];\n  state.order[newIndex] = action.payload.id;\n};\n\nconst findIndexByPayloadId = (state, action) => {\n  return state.order.findIndex(id => id === action.payload.id);\n};\n\nconst updateCell = (state, action) => {\n  const {\n    id,\n    content\n  } = action.payload;\n  state.data[id].content = content;\n};\n\nconst deleteCell = (state, action) => {\n  delete state.data[action.payload];\n  state.order = state.order.filter(id => id !== action.payload);\n};\n\nconst generateRandomId = () => {\n  return Math.random().toString(36).substr(2, 5);\n};\n\nconst insertCellAfter = (state, action) => {\n  const newCell = {\n    id: generateRandomId(),\n    type: action.payload.type,\n    content: ''\n  };\n  state.data[newCell.id] = newCell;\n  const index = findIndexByPayloadId(state, action);\n\n  if (index < 0) {\n    // place new cell at top if index is first element\n    state.order.unshift(newCell.id);\n  } else {\n    state.order.splice(index + 1, 0, newCell.id);\n  }\n};\n\nexport default reducer;","map":{"version":3,"sources":["/home/pac/cheatsheets/packages/local-client/src/state/reducers/cells-reducer.ts"],"names":["produce","ActionType","Direction","initialState","loading","error","order","data","reducer","state","action","type","MOVE_CELL","moveCell","UPDATE_CELL","updateCell","DELETE_CELL","deleteCell","INSERT_CELL_AFTER","insertCellAfter","direction","payload","currentIndex","findIndexByPayloadId","newIndex","UP","indexOutOfBounds","length","id","findIndex","content","filter","generateRandomId","Math","random","toString","substr","newCell","index","unshift","splice"],"mappings":"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","sourcesContent":["import produce from 'immer';\nimport { ActionType } from '../action-types';\nimport { Action, DeleteCellAction, Direction, InsertCellAfterAction, MoveCellAction, UpdateCellAction } from '../actions';\nimport { Cell } from '../cell';\n\ninterface CellState {\n  loading: boolean;\n  error: string | null;\n  order: string[];\n  data: {\n    [key: string]: Cell;\n  };\n}\n\nconst initialState: CellState = {\n  loading: false,\n  error: null,\n  order: [],\n  data: {},\n};\n\nconst reducer = produce(\n  (state: CellState = initialState, action: Action): CellState => {\n    switch (action.type) {\n      case ActionType.MOVE_CELL:\n        moveCell(state, action);\n        return state;\n      case ActionType.UPDATE_CELL:\n        updateCell(state, action);\n        return state;\n      case ActionType.DELETE_CELL:\n        deleteCell(state, action);\n        return state;\n      case ActionType.INSERT_CELL_AFTER:\n        insertCellAfter(state, action);\n        return state;\n      default:\n        return state;\n    }\n  }\n);\n\nconst moveCell = (state: CellState, action: MoveCellAction): void => {\n  const { direction } = action.payload;\n  const currentIndex = findIndexByPayloadId(state, action);\n  const newIndex = direction === Direction.UP ? currentIndex - 1 : currentIndex + 1;\n\n  const indexOutOfBounds = newIndex < 0 || newIndex >= state.order.length;\n  if(indexOutOfBounds) {\n    return;\n  } \n\n  state.order[currentIndex] = state.order[newIndex];\n  state.order[newIndex] = action.payload.id;\n};\n\nconst findIndexByPayloadId = (state: CellState, action: MoveCellAction | InsertCellAfterAction): number => {\n  return state.order.findIndex((id) => id === action.payload.id);\n};\n\nconst updateCell =(state: CellState, action: UpdateCellAction): void => {\n  const { id, content } = action.payload;\n  state.data[id].content = content;\n};\n\nconst deleteCell = (state: CellState, action: DeleteCellAction): void => {\n  delete state.data[action.payload];\n  state.order = state.order.filter(id => id !== action.payload);\n};\n\nconst generateRandomId = (): string => {\n  return Math.random().toString(36).substr(2, 5);\n};\n\nconst insertCellAfter = (state: CellState, action: InsertCellAfterAction) => {\n  const newCell: Cell = {\n    id: generateRandomId(),\n    type: action.payload.type,\n    content: '',\n  };\n  state.data[newCell.id] = newCell;\n\n  const index = findIndexByPayloadId(state, action);\n  if (index < 0) {\n    // place new cell at top if index is first element\n    state.order.unshift(newCell.id);\n  } else {\n    state.order.splice(index + 1, 0, newCell.id);\n  }\n};\n\nexport default reducer;"]},"metadata":{},"sourceType":"module"}